# apps/operations/models.py
from django.db import models
import uuid
from django.contrib.auth.models import User
from django.utils import timezone
from django.conf import settings
from datetime import timedelta
from .enums import OperationStatus, FileType


class Operation(models.Model):
    """
    Represents a media processing operation.
    
    An operation is created when a user submits a file for processing.
    It tracks the status, progress, and metadata of the processing task.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session_key = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    user = models.ForeignKey(User, null=True, blank=True, on_delete=models.CASCADE, related_name='operations')

    operation = models.CharField(max_length=100, db_index=True)
    status = models.CharField(
        max_length=20,
        choices=OperationStatus.choices,
        default=OperationStatus.PENDING,
        db_index=True
    )

    parameters = models.JSONField(default=dict, blank=True)
    progress = models.IntegerField(default=0)
    error_message = models.TextField(null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    expires_at = models.DateTimeField(null=True, blank=True, db_index=True)

    is_deleted = models.BooleanField(default=False, db_index=True)

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['session_key', 'status']),
            models.Index(fields=['user', 'status']),
            models.Index(fields=['status', 'created_at']),
        ]
        verbose_name = 'Operation'
        verbose_name_plural = 'Operations'
    
    def __str__(self):
        return f"Operation {self.id} - {self.operation} ({self.status})"
    
    def save(self, *args, **kwargs):
        """Overide save to set expiration date automatically."""
        if not self.expires_at and self.completed_at:
            # set expiration to 7 days after completion
            self.expires_at = self.completed_at + timedelta(days=7)
        super().save(*args, **kwargs)
    
    @property
    def is_expired(self):
        """Check if the operation has expired"""
        if not self.expires_at:
            return False
        return timezone.now() >= self.expires_at
    
    @property
    def processing_time(self):
        """Calculate the processing time in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None
    
    @property
    def is_processing(self):
        """Check if an operation is currently being processed."""
        return self.status in [OperationStatus.QUEUED, OperationStatus.PROCESSING]
    
    def can_be_deleted(self):
        """Determine if the operation can be safely deleted."""
        return self.status in [OperationStatus.COMPLETED, OperationStatus.FAILED] or self.is_expired
    
    def can_be_retried(self):
        """Determine if the operation can be retried."""
        return self.status == OperationStatus.FAILED
    

class File(models.Model):
    """
    Represents a file associated with an operation.
    
    Files can be either input files (uploaded by user) or output files
    (generated by processing).
    Files are stored in Cloudinary when USE_CLOUDINARY is enabled, otherwise stored locally.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    operation = models.ForeignKey(Operation, on_delete=models.CASCADE, related_name='files')

    file_type = models.CharField(
        max_length=10,
        choices=FileType.choices,
        db_index=True
    )

    file_path = models.CharField(max_length=500, blank=True, default='')
    file_name = models.CharField(max_length=255)
    file_size = models.BigIntegerField()
    mime_type = models.CharField(max_length=100)

    cloudinary_public_id = models.CharField(
        max_length=500,
        blank=True,
        default='',
        db_index=True,
        help_text="Cloudinary public ID for the file"
    )
    cloudinary_url = models.URLField(
        max_length=1000,
        blank=True,
        default='',
        help_text="Cloudinary secure URL for the file"
    )
    cloudinary_resource_type = models.CharField(
        max_length=20,
        blank=True,
        default='',
        help_text="Cloudinary resource type (image, video, raw)"
    )

    metadata = models.JSONField(default=dict, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['operation', 'file_type']),
            models.Index(fields=['cloudinary_public_id']),
        ]
        verbose_name = 'File'
        verbose_name_plural = 'Files'
    
    def __str__(self):
        return f"{self.file_type.upper()}: {self.file_name} (operation: {self.operation.id})"
    
    @property
    def is_cloudinary_stored(self) -> bool:
        """Check if the file is stored in Cloudinary."""
        return bool(self.cloudinary_public_id)
    
    @property
    def storage_location(self) -> str:
        """Get a human-readable storage location identifier."""
        if self.is_cloudinary_stored:
            return "cloudinary"
        return "local"
    
    @property
    def file_url(self):
        """Generate the url path for accessing files"""
        if self.cloudinary_url:
            return self.cloudinary_url
        
        # Fallback to local storage URL
        if self.file_path:
            return f"{settings.MEDIA_URL}{self.file_path}"
        
        return ""
    
    @property
    def download_url(self) -> str:
        """
        Generate a download URL for the file
        """
        if self.is_cloudinary_stored:
            from .services.cloudinary_storage import CloudinaryStorageService
            return CloudinaryStorageService.get_download_url(
                public_id=self.cloudinary_public_id,
                resource_type=self.cloudinary_resource_type or 'auto',
                attachment=True,
            )
        
        # Fallback to local file URL
        return self.file_url
    
    def get_cloudinary_info(self) -> dict:
        """
        Get Cloudinary-specific information for API responses
        """
        if not self.is_cloudinary_stored:
            return {}
        
        return {
            'public_id': self.cloudinary_public_id,
            'url': self.cloudinary_url,
            'resource_type': self.cloudinary_resource_type,
            'storage': 'cloudinary',
        }
